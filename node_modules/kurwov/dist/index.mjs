class MarkovData {
  constructor(data) {
    this.finalData = {};
    this.startData = [];
    this.endDelimiter = "\u{FFF0F}";
    this.forbidden = Object.getOwnPropertyNames(Object.getPrototypeOf({}));
    this._createData(data);
  }
  async _createData(data) {
    for (let e of data) {
      e += this.endDelimiter;
      const words = e.split(" ");
      this.startData.push(words[0]);
      words.forEach((word, i) => {
        if (this.forbidden.includes(word))
          word = `${word} `;
        const next = words[i + 1];
        if (word === void 0 || next === void 0)
          return;
        if (this.finalData[word] === void 0) {
          this.finalData[word] = [next];
          return;
        }
        this.finalData[word].push(next);
      });
    }
  }
  getStart() {
    const random = Math.floor(Math.random() * this.startData.length);
    return `${this.startData[random]} `;
  }
  getNext(current) {
    if (!current)
      return;
    const data = this.finalData[current.slice(0, -1)];
    if (!data)
      return;
    const random = Math.floor(Math.random() * data.length);
    return data[random].endsWith(" ") ? data[random] : `${data[random]} `;
  }
  async add(data) {
    data += this.endDelimiter;
    const words = data.split(" ");
    this.startData.push(words[0]);
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      const next = words[i + 1];
      if (word === void 0 || next === void 0)
        continue;
      if (!this.finalData[word]) {
        this.finalData[word] = [next];
        continue;
      }
      this.finalData[word].push(next);
    }
  }
}

class Markov {
  static generate(options) {
    const randomData = options.data.getStart();
    return this.choose(randomData, options.data, randomData, options.maxLength || 1e3);
  }
  static choose(current, markovData, sequence, maxLength) {
    if (sequence.endsWith(`${markovData.endDelimiter} `))
      return sequence.replaceAll(`${markovData.endDelimiter} `, "");
    if (sequence.length >= maxLength)
      return sequence;
    const next = markovData.getNext(current);
    if (!next)
      return sequence;
    sequence += next;
    return this.choose(next, markovData, sequence, maxLength);
  }
  static complete(options) {
    const { start } = options;
    return this.choose(start, options.data, start, options.maxLength || 1e3);
  }
}

export { Markov, MarkovData };
