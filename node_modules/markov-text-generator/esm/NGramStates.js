"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _NGram = _interopRequireDefault(require("./NGram.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var NGramStates =
/*#__PURE__*/
function () {
  function NGramStates(text, order, options) {
    _classCallCheck(this, NGramStates);

    this._trainingText = text.split(/\s+/g).filter(options.filterFunction);
    this._textmap = new Map();
    this._order = order;

    this._buildStates();
  }

  _createClass(NGramStates, [{
    key: "getNGramStates",
    value: function getNGramStates() {
      return this._textmap;
    }
  }, {
    key: "_buildStates",
    value: function _buildStates() {
      this._textmap.clear();

      for (var i = 0; i < this._trainingText.length - (this._order - 1); i++) {
        var nGram = new _NGram.default(this._trainingText, i, this._order);
        var words = nGram.wordsToString();

        if (!this._textmap.has(words)) {
          this._textmap.set(words, this._getFollowingWords(nGram));
        }
      } //	console.log(this._textmap);

    }
  }, {
    key: "_getFollowingWords",
    value: function _getFollowingWords(nGram) {
      var arrWords = [];
      var start = 0;
      var nGramLength = nGram.length();

      while (start < this._trainingText.length - nGramLength) {
        var ind = this._indexOf(this._trainingText, nGram, start);

        if (ind != -1 && ind < this._trainingText.length - nGramLength) {
          arrWords.push(this._trainingText[ind + nGramLength]);
          start = ind + nGramLength;
        } else {
          break;
        }
      }

      return arrWords;
    }
  }, {
    key: "_indexOf",
    value: function _indexOf(words, target, start) {
      var ind = -1;

      if (target.length() >= words.length || start > words.length - this._order) {
        return ind;
      }

      for (var i = start; i < words.length - target.length() + 1; i++) {
        if (words[i] === target.wordAt(0)) {
          for (var j = 0; j < target.length(); j++) {
            if (words[i + j] !== target.wordAt(j)) {
              ind = -1;
              break;
            }

            ind = i;
          }
        }

        if (ind != -1) {
          break;
        }
      }

      return ind;
    }
  }]);

  return NGramStates;
}();

var _default = NGramStates;
exports.default = _default;