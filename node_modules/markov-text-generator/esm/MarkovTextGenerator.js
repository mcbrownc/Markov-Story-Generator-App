"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _NGramStates = _interopRequireDefault(require("./NGramStates.js"));

var _TextChain = _interopRequireDefault(require("./TextChain.js"));

var _seedrandom = _interopRequireDefault(require("seedrandom"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var defaultOptions = {
  startAsSentence: true,
  endAsSentence: false,
  filterFunction: function filterFunction(word) {
    return true;
  }
};

var MarkovTextGenerator =
/*#__PURE__*/
function () {
  /**
   * Markov Text Generator.
   *
   * @constructor
   * @param {number} [order=2] Markov order.
   * @param {Object[]} options
   * @param {boolean} [options.startAsSentence=true] Whether first word in generated text should start with uppercase letter.
   * @param {boolean} [options.endAsSentence=true] Whether last word in generated text should end with punctuation.
   * NB. if set to true, the number of generated words may equal more than number sent to generateText() method.
   * @param {Function} [options.filterFunction] A custom filter function to remove unwanted words.
   * @example
   * import MarkovTextGenerator from "./markov.js";
   * const options = {
   *  startAsSentence: true,
   *  endAsSentence: false,
   *  filterFunction: word => word.indexOf("http") === -1
   * };
   * const markov = new MarkovTextGenerator(2, options);
   * markov.setTrainingText("a long text string goes here");
   * markov.generateText(50);
   */
  function MarkovTextGenerator() {
    var order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;

    _classCallCheck(this, MarkovTextGenerator);

    this._options = options;
    this._order = order;
    this.textChain = {};
    this.nGramStates = {};

    this._validateParams();
  }

  _createClass(MarkovTextGenerator, [{
    key: "_validateParams",
    value: function _validateParams() {
      if (typeof this._order !== "number" || this._order < 1) {
        throw new TypeError("MarkovTextGenerator constructor: order parameter must be a positive number");
      }

      if (this._options.filterFunction && typeof this._options.filterFunction !== "function") {
        throw new TypeError("MarkovTextGenerator constructor: filterFunction must be a Function");
      }

      if (this._options.filterFunction && typeof this._options.filterFunction("test") !== "boolean") {
        throw new TypeError("MarkovTextGenerator constructor: filterFunction must return a boolean");
      }
    }
    /**
     * Set training text for generator to build map of words.
     * @param {string} words A string of source text
     */

  }, {
    key: "setTrainingText",
    value: function setTrainingText(text) {
      if (!this._options.filterFunction) {
        this._options.filterFunction = defaultOptions.filterFunction;
      }

      this.nGramStates = new _NGramStates.default(text, this._order, this._options);
      this.textChain = new _TextChain.default(this.nGramStates.getNGramStates(), this._order, this._options);
    }
    /**
     * Generate text based on training data
     * @param {number} numWords Number of words to be returned.
     * @return {string} A string of generated words.
     */

  }, {
    key: "generateText",
    value: function generateText(numWords) {
      return this.textChain.generate(numWords);
    }
    /**
     * Set seed to be used Math.random() - for testing purposes.
     * @param {string} seed
     */

  }, {
    key: "setSeed",
    value: function setSeed(seed) {
      Math.seedrandom(seed);
    }
  }]);

  return MarkovTextGenerator;
}();

var _default = MarkovTextGenerator;
exports.default = _default;